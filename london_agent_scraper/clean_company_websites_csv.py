#!/usr/bin/env python3
"""Utility to clean scraper_company_websites output CSV files."""

from __future__ import annotations

import argparse
import csv
import re
from pathlib import Path
from typing import Iterable, Tuple

EMAIL_PATTERN = re.compile(r"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$")
PLACEHOLDER_DOMAINS = {
    "example.com",
    "example.net",
    "example.org",
    "example.co.uk",
}
UNLIKELY_TLDS = {
    "jpg",
    "jpeg",
    "png",
    "gif",
    "svg",
    "webp",
}


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Filter a scraped company websites CSV to remove invalid emails and duplicates."
        )
    )
    parser.add_argument(
        "input_csv",
        type=Path,
        help="Path to the CSV generated by scraper_company_websites.py",
    )
    parser.add_argument(
        "--output-csv",
        type=Path,
        default=None,
        help=(
            "Destination for the cleaned CSV. Defaults to adding '_cleaned' before the"
            " extension of the input file."
        ),
    )
    parser.add_argument(
        "--invalid-report",
        type=Path,
        default=None,
        help=(
            "Optional path to write a CSV containing rows that were discarded due to"
            " blank/invalid emails."
        ),
    )
    return parser.parse_args()


def normalise(value: str) -> str:
    return value.strip()


def email_is_valid(email: str) -> bool:
    if not email:
        return False

    match = EMAIL_PATTERN.match(email)
    if match is None:
        return False

    _, domain = email.rsplit("@", 1)
    domain_lower = domain.lower()
    if domain_lower in PLACEHOLDER_DOMAINS:
        return False

    tld = domain_lower.rsplit(".", 1)[-1]
    if tld in UNLIKELY_TLDS:
        return False

    return True


def derive_paths(input_csv: Path, output_csv: Path | None, invalid_report: Path | None) -> Tuple[Path, Path | None]:
    if output_csv is None:
        output_csv = input_csv.with_name(
            f"{input_csv.stem}_cleaned{input_csv.suffix}"
        )
    if invalid_report is None:
        return output_csv, None
    return output_csv, invalid_report


def clean_rows(rows: Iterable[dict]) -> Tuple[list[dict], list[dict]]:
    seen: set[Tuple[str, str]] = set()
    cleaned: list[dict] = []
    rejected: list[dict] = []

    for row in rows:
        company = normalise(row.get("company_name", ""))
        website = normalise(row.get("website", ""))
        email = normalise(row.get("email", ""))

        if not email_is_valid(email):
            rejected.append({"company_name": company, "website": website, "email": email})
            continue

        key = (website.lower(), email.lower())
        if key in seen:
            continue
        seen.add(key)

        cleaned.append(
            {
                "company_name": company,
                "website": website,
                "email": email,
            }
        )

    return cleaned, rejected


def write_csv(path: Path, rows: Iterable[dict]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", newline="") as handle:
        writer = csv.DictWriter(handle, fieldnames=["company_name", "website", "email"])
        writer.writeheader()
        for row in rows:
            writer.writerow(row)


def main() -> None:
    args = parse_args()
    output_csv, invalid_report = derive_paths(args.input_csv, args.output_csv, args.invalid_report)

    with args.input_csv.open(newline="") as handle:
        reader = csv.DictReader(handle)
        cleaned, rejected = clean_rows(reader)

    write_csv(output_csv, cleaned)

    if invalid_report is not None and rejected:
        write_csv(invalid_report, rejected)

    if invalid_report is None:
        if rejected:
            print(f"Discarded {len(rejected)} rows with invalid/blank emails.")
        print(f"Wrote {len(cleaned)} cleaned rows to {output_csv}")
    else:
        print(
            f"Wrote {len(cleaned)} cleaned rows to {output_csv} and"
            f" {len(rejected)} rejected rows to {invalid_report}"
        )


if __name__ == "__main__":
    main()
